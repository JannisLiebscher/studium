Kapitel 4 ‚Äì Rendering and Visibility

Visibility test - Komplex. der Szene f√ºr nachfolgende Schritte der Rendering-pipeline reduzieren.
	-immediate change, in realtime
Occulsion: Wenn 2 Punkte der 3D Szene auf einen Pixel im 2D-Space gemapped werden.

Object space(f√ºr jedes Objekt) vs Image space(f√ºr jeden Pixel) Methods

Back Face Culling: R√ºckseiten entfernen, also fl√§chen, die vom Objekt selbst verdeckt werden.
	Normal verwenden, skalarprodukt zwischen ViewDir und Normal (o	v * N > 0 = Invisible)
	schnell, Komplexit√§t -50%, nur bedingt m√∂glich f√ºr  konkave Polyeder

Frustum Culling: Testet Intersections zwischen View Frustum und Bounding Box/sphere des Objektes.

Occlusion Culling: So Tun als w√ºrde man Bounding Box Rendern, gerenderte Pixel z√§hlen. Falls null kann Objekt weg, 	ansonnsten nochmal genauer schauen.
		Pop-in/pop-out effects in animations possible (Wenn Bounding Box von verdeckendem Objekt zu gro√ü)

Z-Buffer: Zus√§tzlicher Speicher, der f√ºr jeden Pixel kleinsten Z-Wert speichert. Initialisierung mit gr√∂√üstem Z-	Wert, Frame Buffer mit Hintergrundfarbe. Neues Objekt rendern: Z-Buffer checken, wo es verdeckt wird. Z-		Werte mit ebenengleichung Inkrementel berechnen: Tiefen Koherenz
	Probleme: Weit entfernte objekte, Z-Buffer AUfl√∂sung zu klein.

Alpha-Buffer: Wie Z-Buffer, f√ºr Transparency-Werte(0-1). Erstes Undurchsichtiges Objekt suchen, dann von hinten nach vorne.

Ray-Casting: Strahl von Eye-Point durch ImagePlane casten, Intersections mit Objekten berechnen, n√§chstes Objekt 	ist an diesem Pixel sichtbar.
	F√ºr Schnittpunkt Geradengleichung(View-Ray) in Ebenen/Kugelgleichung einsetzen und aufl√∂sen

Ray Casting ist sehr aufwendig. Back-Face Culling und Boundign Boxes reduzieren Komplexit√§t.
Transform the rays onto the ùëß-axis: Schnittpunkt immer bei x=y=0 => einfacher zu berechnen.
Vermeidung unn√∂tiger Berechnungen durch verwendung von hierachischen Datenstrukturen.

Illumination Model: Wie berechne ich an einem bestimmten Punkt die Intensity(Farbe) Eines Pixels?
Shading Model: Wann und wo wird Illumination Model ausgewertet?

Phong Illumination: = specular component, diffuse component, ambient light
	specular und diffuse h√§ngen vom EInfallswinkel des Lichts ab
Ambient: Ambient Light Intensitiy * Ambient Component
Diffuse: Light Intensity * L*N (Skalar) * Diffuse Component
Specular: Light Intensity * V*R^n (Skalar) * Diffuse Component	(gro√ües n = Spiegel)
Phong wird f√ºr jede Farbe (RGB) angewandt

(Blinn-Illumination model. Verwendet Halbvektor, ist effizienter, aber nur Ann√§herung an Phong)

Sieht Plastik-Like aus. Keine Interaktion(Mirror-Image etc)

